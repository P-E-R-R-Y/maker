/**
 * @file CMake.hpp
 * @author Perry Chouteau (perry.chouteau@outlook.com)
 * @brief 
 * @version 0.1
 * @date 01-05-2025
 * 
 * @copyright Copyright (c) 2025
 * 
 */

#ifndef CMAKE_HPP
#define CMAKE_HPP

#include <fstream>
#include <nlohmann/json.hpp>
#include <iostream>

#include "Repository.hpp"
#include "Warn.hpp"

using json = nlohmann::json;

class CMake {
    public:

        static void cmake(json j) {
            std::string path = Repository::instance().get();
            std::ofstream cmakeFile(path + "/CMakeLists.txt");
            if (!cmakeFile.is_open()) {
                std::cerr << "Error: Could not open CMakeLists.txt for writing." << std::endl;
            }
            cmakeFile << "# Generated by P-E-R-R-Y/maker" << std::endl << std::endl;
            if (j.contains("general") && j["general"].is_object()) {
                general(cmakeFile, j["general"]);
            } else {
                std::cerr << "Warn: JSON file does not contain 'general' key." << std::endl;
            }
            if (j.contains("deps") && j["deps"].is_object()) {
                deps(cmakeFile, j["deps"]);
            } else {
                std::cerr << "Warn: JSON file does not contain 'deps' key." << std::endl;
            }
            if (j.contains("deps") && j["deps"].is_object() && j["deps"].contains("shared") && j["deps"]["shared"].is_array()) {
                assets(cmakeFile, j["deps"]["shared"]);
            } else {
                std::cerr << "Warn: JSON file does not contain 'assets' key." << std::endl;
            }
            if (j.contains("project") && j["project"].is_object()) {
                project(cmakeFile, j["project"]);
            } else {
                std::cerr << "Warn: JSON file does not contain 'project' key." << std::endl;
            }
            if (j.contains("include") && j["include"].is_object()) {
                include(cmakeFile, j["include"]);
            } else {
                std::cerr << "Warn: JSON file does not contain 'include' key." << std::endl;
            }
            if (j.contains("dev") && j["dev"].is_object()) {
                dev(cmakeFile, j["dev"]);
            } else {
                std::cerr << "Warn: JSON file does not contain 'dev' key." << std::endl;
            }
            Warn::warn(j);
            cmakeFile.close();
        }

        static void general(std::ofstream& f, json j) {
            bool err = false;

            f << "# ----------- general -----------" << std::endl << std::endl;
            if (!j.contains("name") || !j["name"].is_string()) {
                std::cerr << "Error: JSON file does not contain 'name' key." << std::endl;
                err = true;
            }
            if (!j.contains("version") || !j["version"].is_string()) {
                std::cerr << "Error: JSON file does not contain 'version' key." << std::endl;
                err = true;
            } 
            if (!j.contains("cpp_standard") || !j["cpp_standard"].is_string()) {
                std::cerr << "Error: JSON file does not contain 'cpp_standard' key." << std::endl;
                err = true;
            }
            if (!j.contains("cpp_standard_required") || !j["cpp_standard_required"].is_boolean()) {
                std::cerr << "Error: JSON file does not contain 'path' key." << std::endl;
                err = true;
            }
            Warn::warn(j);            
            if (err) {
                return;
            }

            f << "cmake_minimum_required(VERSION " << j["version"].get<std::string>() <<")" << std::endl;
            f << "project(" << j["name"].get<std::string>() << ")" << std::endl;
            f << std::endl;
            f << "set(CMAKE_CXX_STANDARD " << j["cpp_standard"].get<std::string>() << ")" << std::endl;
            f << "set(CMAKE_CXX_STANDARD_REQUIRED " << ((j["cpp_standard_required"]) ? "ON" : "OFF") << ")" << std::endl;
        }

        /**
         * @brief read json-dependencies, sharedList, staticList, find_package
         * 
         * @todo shared & static with option to use
         * 
         * @param f 
         * @param j 
         */
        static void deps(std::ofstream& f, json j) {
            bool mod = false;
            std::vector<std::string> sharedLib;
            std::vector<std::string> staticLib;

            f << std::endl << "# ----------- deps -----------" << std::endl << std::endl;

            //mod
            if (j.contains("shared") && j["shared"].is_array()) {
                for (auto&item : j["shared"]) {
                    if (item.is_object() && (item.contains("git") || item.contains("url"))) {
                        mod = true;
                        break;
                    }
                }   
            }
            if (j.contains("static") && j["static"].is_array() && !mod) {
                for (auto&item : j["static"]) {
                    if (item.is_object() && (item.contains("git") || item.contains("url"))) {
                        mod = true;
                        break;
                    }
                }
            }
            if (mod) {
                f << "list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)" << std::endl << std::endl;
            }
            
            //shared
            if (j.contains("shared") && j["shared"].is_array()) {
                f << "list(APPEND CMAKE_BIN_SHARED" << std::endl;
                
                for (auto& item : j["shared"]) {
                    if (item.is_object()) {
                        if (item.contains("name") && item["name"].is_string()) {
                            f << "    " << item["name"].get<std::string>() << std::endl;
                        }
                    }
                }
                f << ")" << std::endl << std::endl;
                // loop over all shared libs while fidding package                
                f << "foreach(sharedlib IN LISTS CMAKE_BIN_SHARED)" << std::endl;
                f << "    find_package(${sharedlib} REQUIRED)" << std::endl;
                f << "endforeach()" << std::endl << std::endl;
            }

            //static
            if (j.contains("static") && j["static"].is_array()) {
                f << "list(APPEND CMAKE_BIN_STATIC" << std::endl;
                
                for (auto& item : j["static"]) {
                    if (item.is_object()) {
                        if (item.contains("name") && item["name"].is_string()) {
                            f << "    " << item["name"].get<std::string>() << std::endl;
                        }
                    }
                }
                f << ")" << std::endl << std::endl;
                // loop over all shared libs while fidding package                
                f << "foreach(staticlib IN LISTS CMAKE_BIN_STATIC)" << std::endl;
                f << "    find_package(${staticlib} REQUIRED)" << std::endl;
                f << "endforeach()" << std::endl;
            }
        }
        
        /**
         * @brief array of shared assets
         * 
         * @param f 
         * @param j 
         */
        static void assets(std::ofstream& f, json j) {
            f << std::endl << "# ----------- assets -----------" << std::endl << std::endl;
            
            f << "file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/assets DESTINATION ${CMAKE_BINARY_DIR})" << std::endl << std::endl;

            f << std::endl << "# ----------- shared assets -----------" << std::endl << std::endl;

            f << "set(assetpath ${CMAKE_BINARY_DIR}/assets/shared/)" << std::endl;
            f << "file(MAKE_DIRECTORY ${assetpath})" << std::endl << std::endl;

            f << "foreach(sharedlib IN LISTS CMAKE_BIN_SHARED)" << std::endl;
            f << "\tset(sharedlibpath ${CMAKE_BINARY_DIR}/_deps/${sharedlib}-build/lib${sharedlib}${CMAKE_SHARED_LIBRARY_SUFFIX})" << std::endl << std::endl;

            f << "\tadd_custom_target(copy_${sharedlib} ALL)" << std::endl;
            f << "\tadd_dependencies(copy_${sharedlib} ${sharedlib})" << std::endl << std::endl;

            f << "\tadd_custom_command(TARGET copy_${sharedlib}" << std::endl;
            f << "\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different" << std::endl;
            f << "\t\t${sharedlibpath}" << std::endl;
            f << "\t\t${assetpath}" << std::endl;
            f << "\t)" << std::endl;
            f << "endforeach()" << std::endl << std::endl;

            Warn::warn(j);
        }

        static void project(std::ofstream& f, json j) {
            f << std::endl << "# ----------- project -----------" << std::endl << std::endl;

            f << "set(SOURCE_FILES" << std::endl;
            if (j.contains("sources") && j["sources"].is_array()) {
                for (auto& item : j["sources"]) {
                    if (item.is_string()) {
                        f << "    sources/" << item.get<std::string>() << std::endl;
                    }
                }
                f << ")" << std::endl << std::endl;
            } else {
                std::cerr << "Warn: JSON file does not contain 'sources' key." << std::endl;
            }

            if (j.contains("type") && j["type"].is_string()) {
                if (j["type"].get<std::string>() == "shared") {
                    f << "add_library(${PROJECT_NAME} SHARED ${SOURCE_FILES})" << std::endl;
                } else if (j["type"].get<std::string>() == "static") {
                    f << "add_library(${PROJECT_NAME} STATIC ${SOURCE_FILES})" << std::endl;
                } else if (j["type"].get<std::string>() == "executable") {
                    f << "add_executable(${PROJECT_NAME} ${SOURCE_FILES})" << std::endl;
                } else {
                    std::cerr << "Error: project->type is invalid." << std::endl;
                    return;
                }
            } else {
                std::cerr << "Error: project->type isn't defined." << std::endl;
            }

            if (j.contains("libraries") && j["libraries"].is_array()) {
                f << "target_link_libraries(${PROJECT_NAME}" << std::endl;
                for (auto& item : j["libraries"]) {
                    if (item.is_string()) {
                        f << "    " << item.get<std::string>() << std::endl;
                    }
                }
                f << ")" << std::endl << std::endl;
            } else {
                std::cerr << "Warn: JSON file does not contain 'libraries' key." << std::endl;
            }
        }

        static void include(std::ofstream& f, json j) {
            f << std::endl << "# ----------- include -----------" << std::endl << std::endl;
            f << "target_include_directories(${PROJECT_NAME} ";
            if (j.contains("type") && j["type"].is_string()) {
                if (j["type"].get<std::string>() == "public") {
                    f << "PUBLIC" << std::endl;
                } else if (j["type"].get<std::string>() == "private") {
                    f << "PRIVATE" << std::endl;
                } else if (j["type"].get<std::string>() == "interface") {
                    f << "INTERFACE" << std::endl;
                } else {
                    std::cerr << "ERROR: JSON file does not contain 'type' key." << std::endl;
                }
            } else {
                f << "PUBLIC" << std::endl;
                std::cerr << "ERROR: JSON file does not contain 'include->type' key." << std::endl;
            }
            f << "\t${CMAKE_CURRENT_SOURCE_DIR}/includes/" << std::endl;
            f << ")" << std::endl << std::endl;


        }

        static void dev(std::ofstream& f, json j) {
            f << std::endl << "#----------- dev -----------" << std::endl << std::endl;

            if (j.contains("cxxflags") && j["cxxflags"].is_array()) {
                f << "target_compile_options(${PROJECT_NAME} PRIVATE";
                for (auto& item : j["cxxflags"]) {
                    if (item.is_string()) {
                        f  << " " << item.get<std::string>();
                    }
                }
                f << ")" << std::endl;
            } else {
                std::cerr << "Warn: JSON file does not contain 'options' key." << std::endl;
            }

        }

};

#endif // CMAKE_HPP